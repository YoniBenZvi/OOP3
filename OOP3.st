Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'interface' stamp: 'compile:where: 12/8/2018 18:03'!ambiguities	|bLikeIFs numOfIFs ambiguitiesCollection allOfMethods|	bLikeIFs := self behavesLike.	numOfIFs := bLikeIFs size.	ambiguitiesCollection := Set new.	allOfMethods := Set new.	bLikeIFs do:		[:tmpIF | tmpIF selectorsDo:			[:tmpSelector | 				(allOfMethods addNewElement: tmpSelector)				ifFalse:[					"causes an ambiguity"					ambiguitiesCollection add: (tmpSelector). 				].			].		].	^(ambiguitiesCollection asSortedCollection)! !!MyObject class methodsFor: 'interface' stamp: 'compile:where: 12/7/2018 20:05'!behavesLike	(self class = MyObject class) 		ifTrue: [^(Set new).]		ifFalse: [^behavesLike.].! !!MyObject class methodsFor: 'interface' stamp: 'compile:where: 12/7/2018 20:06'!isInterface	(self class = MyObject class) 		ifTrue: [^false.]		ifFalse: [^isInterface.].! !!MyObject class methodsFor: 'interface' stamp: 'compile:where: 12/7/2018 21:44'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName	|addBehavesLike|	addBehavesLike := Set new.	(self class = MyObject class)		ifFalse:[addBehavesLike = super behavesLike.].	^(self   subclass: aSubclassName 			isInterface: false 			behavesLike: addBehavesLike			instanceVariableNames: instVarNames 			classVariableNames: classVarNames 			poolDictionaries: poolDictionaries			category: aCategoryName).! !!MyObject class methodsFor: 'interface' stamp: 'compile:where: 12/7/2018 22:12'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName|newClass behavesCollection|	newClass := (super subclass: aSubclassName    				 instanceVariableNames: instVarNames			       classVariableNames:classVarNames			       poolDictionaries: poolDictionaries			       category: aCategoryName).	(newClass)  instVarNamed: 'behavesLike' put: (Set new);				instVarNamed: 'isInterface' put: isInterface.	behavesCollection := self behavesLike.	isInterface ifTrue: [behavesCollection add: newClass].	aCollection do:[:tmpClass | behavesCollection add: tmpClass.		(tmpClass behavesLike) do: [:x| behavesCollection add: x.].].	(newClass)  instVarNamed: 'behavesLike' put: (behavesCollection).	^(newClass new).! !!MyObject class methodsFor: 'compiling' stamp: 'compile:where: 12/7/2018 14:06'!compile: aSourceCode where: anOrderedCollection	|sourceCodeLines numOfArgs newCompileCheck newCode|	sourceCodeLines := aSourceCode lines.	numOfArgs := (sourceCodeLines at: 1) occurrencesOf: $:.	(numOfArgs ~~ anOrderedCollection size) ifTrue:		[AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'].	newCompileCheck := self getCompileCheck: (((sourceCodeLines at: 1 ) copyReplaceAll: ':' with: ': ') findTokens: ' ') where: anOrderedCollection.	newCode := self insertCompileCheck: newCompileCheck toCode: sourceCodeLines.	self compile: newCode.! !!MyObject class methodsFor: 'compiling' stamp: 'compile:where: 12/7/2018 13:34'!getCompileCheck: selectorWithArgsArray where: anOrderedCollection	|endL addTab compileCheck|	endL := Character cr asString. 	addTab := Character tab asString. compileCheck := String new.	1 to: (anOrderedCollection size)  do: 		[:i | ((anOrderedCollection at: i ) isNil) ifFalse:[			compileCheck := compileCheck , 			addTab, '(', (selectorWithArgsArray at: (i*2)) , ' isKindOf: ', ((anOrderedCollection at: i ) asString ) , ') ',			'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument ',  i asString, 				' should be ', (anOrderedCollection at: i ) asString , '''.].' , endL.].		].	^compileCheck.	! !!MyObject class methodsFor: 'compiling' stamp: 'compile:where: 12/7/2018 13:15'!insertCompileCheck: compileCheck toCode: sourceCodeLinesArray	|i endL addTab newCode|	endL := Character cr asString. 	addTab := Character tab asString. 	newCode := (sourceCodeLinesArray at:1) , endL.	((sourceCodeLinesArray at:2) includes: $|)		ifTrue:[newCode := newCode , addTab, (sourceCodeLinesArray at:2), endL.				i := 3.]		ifFalse:[i := 2.].	newCode := newCode, compileCheck.	i to: (sourceCodeLinesArray size) do:		[:x | newCode := newCode, addTab, (sourceCodeLinesArray at:x), endL].	^newCode.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'compile:where: 12/7/2018 18:27'!methodIsEmpty: aSourceCode	"receives a code of a method as a string, and returns if the method is empty or not"	|sourceCodeLines isEmpty|	sourceCodeLines := aSourceCode lines. isEmpty := true.	2 to: sourceCodeLines size do: 		[:i |			 (((sourceCodeLines at: i) withBlanksCondensed) size = 0)			ifFalse: [ (((sourceCodeLines at: i) withBlanksCondensed)= '^ self')				 ifFalse:[					isEmpty := false.				].			].		].	^isEmpty.! !!MyObject class methodsFor: 'as yet unclassified' stamp: 'compile:where: 12/7/2018 18:49'!methodIsImplemented: aSelector	"receives a selector of a method (as a string!!!!!!), and returns if the method is implemented by this class (or any of it's 	super classes) or not"	"if the selector wasn't found - returns false"	^[((self methodIsEmpty: ((self decompile: (aSelector asSymbol)) asString)) not).]		on: Error	"the method wasn't found in the methodDict"		do:  [(self = MyObject class) ifTrue: [^false]			ifFalse: [^superclass methodIsImplemented: aSelector.].]! !